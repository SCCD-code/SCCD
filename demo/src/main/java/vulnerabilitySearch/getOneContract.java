package vulnerabilitySearch;

import java.util.*;
import java.io.IOException;
import myutils.Func;
import org.antlr.v4.runtime.ANTLRErrorListener;
import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.Lexer;
import org.antlr.v4.runtime.Parser;
import org.antlr.v4.runtime.RecognitionException;
import org.antlr.v4.runtime.Recognizer;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.dfa.DFA;
import org.antlr.v4.runtime.atn.ATNConfigSet;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.Trees;
import org.antlr.v4.runtime.misc.Interval;
import antlr4Sol.SolidityLexer;
import antlr4Sol.SolidityParser;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.LinkedList;

public class getOneContract {
    private static HashSet<Integer>  contratSet = new HashSet<>();
    private int projectPathLength = "/bdata/wyk/SmartContract/dataset/smart-contract-sanctuary/".length();
    public static void main(String[] args) {
        getOneContract gct = new getOneContract();
        List<String> allVunl = gct.GetDirectory("/bdata/wyk/SmartContract/dataset/smart-contract-sanctuary/vulnerabilities/");
        File writeFile = new File("oneContract.csv");
        try{
            BufferedWriter writeText = new BufferedWriter(new FileWriter(writeFile));

            for (String path : allVunl) {
                Map<Integer, Func> funcMap = gct.getContractLevelInfo(path);
                if (funcMap.size() >= 1) {
                    for (Func func : funcMap.values()) {
                        writeText.write(func.fileName+","+func.startLine+","+
                        func.endLine+","+func.funcLen+","+func.divTokenSequence.size()+
                        ","+func.astNodeNum+","+func.divTokenSequence.hashCode());
                        writeText.newLine();
                    }
                }
            }

            writeText.flush();
            writeText.close();
        }catch (FileNotFoundException e){
            System.out.println("Don't find allFunctionMap.csv file!");
        }catch (IOException e){
            System.out.println("File write/read error!");
        }
        System.out.println("num"+contratSet.size());
        
    }

    private ArrayList<String> GetDirectory(String path) {
        File file = new File(path);
        LinkedList<File> dirList = new LinkedList<>();
        ArrayList<String> fileList = new ArrayList<>();
        getOneDir(file, dirList, fileList);
        File tmp;
        while (!dirList.isEmpty()) {
            tmp = dirList.removeFirst();
            getOneDir(tmp, dirList, fileList);
        }
        return fileList;
    }

    private void getOneDir(File file, LinkedList<File> dirList, ArrayList<String> fileList) {
        File[] files = file.listFiles();
        if (files == null || files.length == 0) {
            return;
        }
        for (File f : files) {
            if (f.isDirectory() && !f.getName().equals("testnet") && !f.getName().equals("mumbai") && !f.getName().equals("kovan")&& !f.getName().equals("rinkeby")&& !f.getName().equals("ropsten")&& !f.getName().equals("goerli")) {
            //if (f.isDirectory()) {  
                dirList.add(f);
            } else if(f.getName().endsWith(".sol")){
                // 这里列出当前文件夹根目录下的所有文件,并添加到fileList列表中
                fileList.add(f.getPath());
            }
        }
    }

    private Map<Integer, Func> getContractLevelInfo(String filePath) {
        Map<Integer, Func> tempFuncs = new HashMap<>();
        try {
            CharStream input = CharStreams.fromFileName(filePath);
            //make lexer
            Lexer lexer = new SolidityLexer(input);
            CommonTokenStream tokenStream = new CommonTokenStream(lexer);
            tokenStream.fill();
            List<Token> tokens = tokenStream.getTokens(0, tokenStream.size()-1);
            SolidityParser parser = new SolidityParser(tokenStream);
            parser.removeErrorListeners();
            parser.addErrorListener(new ANTLRErrorListener() {

                @Override
                public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int line,
                        int charPositionInLine, String msg, RecognitionException e) {
                    // TODO Auto-generated method stub
                    
                }

                @Override
                public void reportAmbiguity(Parser recognizer, DFA dfa, int startIndex, int stopIndex, boolean exact,
                        BitSet ambigAlts, ATNConfigSet configs) {
                    // TODO Auto-generated method stub
                    
                }

                @Override
                public void reportAttemptingFullContext(Parser recognizer, DFA dfa, int startIndex, int stopIndex,
                        BitSet conflictingAlts, ATNConfigSet configs) {
                    // TODO Auto-generated method stub
                    
                }

                @Override
                public void reportContextSensitivity(Parser recognizer, DFA dfa, int startIndex, int stopIndex,
                        int prediction, ATNConfigSet configs) {
                    // TODO Auto-generated method stub
                    
                }
                
            });
            List<String> ruleNamesList = Arrays.asList(parser.getRuleNames());
            ParseTree tree = parser.sourceUnit();

            Queue<ParseTree> visteQueue = new LinkedList<>();
            visteQueue.offer(tree);
            int funcDecHash = "contractDefinition".hashCode();
            int contractHash = "contract".hashCode();
            while(!visteQueue.isEmpty()) {
                ParseTree firstEle = visteQueue.poll();
                int firstEleHash = Trees.getNodeText(firstEle, ruleNamesList).hashCode();
                if (firstEleHash == funcDecHash && Trees.getNodeText(firstEle.getChild(0), ruleNamesList).hashCode() == contractHash) {
                    Interval tmpInterval = firstEle.getSourceInterval();
                    int sIndex = tmpInterval.a;
                    int eIndex = tmpInterval.b;
                    int startLine = tokens.get(sIndex).getLine();
                    int endLine = tokens.get(eIndex).getLine();
                    
                    List<Integer> divTokens = new ArrayList<>();
                    List<Integer> normTokens = new ArrayList<>();
                    List<String> normLines = new ArrayList<>();
                    int curLine = tokens.get(sIndex).getLine();
                    StringBuffer sb = new StringBuffer();
                    for (int i = sIndex; i <= eIndex; i++) {
                        Token tmpToken = tokens.get(i);
                        int tempTokenHash = tmpToken.getText().hashCode();
                        if(tmpToken.getChannel() == 1) {
                            continue;
                        }
                        divTokens.add(tempTokenHash);
                        normTokens.add(tmpToken.getType());
                        if(tmpToken.getLine() == curLine) {
                            //sb.append(tmpToken.getType());
                            sb.append(tempTokenHash);
                        } else {
                            normLines.add(sb.toString());
                            sb = new StringBuffer();
                            curLine = tmpToken.getLine();
                        }
                    }
                    normLines.add(sb.toString());
                    if (normLines.size() < 10) continue;
                    Map<Integer, Short> hashCnt = getASTHashDict(firstEle, ruleNamesList);
                    int astNodeNum = 0;
                    for (int value : hashCnt.values()) {
                        astNodeNum += value;
                    }
                    Func tmpFunc = new Func();
                    
                    tmpFunc.fileName = filePath.substring(projectPathLength);
                    tmpFunc.startLine = (short)startLine;
                    tmpFunc.endLine = (short)endLine;
                    tmpFunc.divTokenSequence = divTokens;
                    contratSet.add(divTokens.hashCode());
                    tmpFunc.astNodeHashCnt = hashCnt;
                    tmpFunc.astNodeNum = (short)astNodeNum;
                    tmpFunc.funcLen = (short)normLines.size();
                    tmpFunc.normTokenSequence = normLines;
                    tempFuncs.put(tmpFunc.funcID, tmpFunc);
                    if(tmpFunc.funcID %100000 == 0) {
                        System.out.println(tmpFunc.funcID+" || token num:" + divTokens.size() + " || ast node num:"+astNodeNum);
                    }
                    
                } else {
                    int tmpChildrenNum = firstEle.getChildCount();
                    for (int i = 0; i < tmpChildrenNum; i++) {
                        if (firstEle.getChild(i).getChildCount() != 0) {
                            visteQueue.offer(firstEle.getChild(i));
                        }
                    }
                }
            }
        } catch (IOException e) {
            //e.printStackTrace();
        }
        return tempFuncs;
    }

    private Map<Integer, Short> getASTHashDict(ParseTree cu, List<String> ruleNamesList) {
        Deque<ParseTree> stack = new ArrayDeque<>();
        Map<ParseTree, Integer> visited = new HashMap<>();

        stack.push(cu);

        while (!stack.isEmpty()) {
            ParseTree node = stack.peek();
            //int h = nodeHeight.get(node);
            int childNodeNum = node.getChildCount();
            if (visited.containsKey(node)) {
                stack.pop();
                String nodeText = Trees.getNodeText(node, ruleNamesList);
                //System.out.println(nodeText);
                int tmpHash = nodeText.hashCode();
                for (int i = 0; i < childNodeNum; i++) {
                    tmpHash += visited.getOrDefault(node.getChild(i), 0);
                }
                visited.put(node, tmpHash);
                continue;
            } else if (childNodeNum == 0){
                stack.pop();
                visited.put(node, Trees.getNodeText(node, ruleNamesList).hashCode());
                continue;
            }
            for (int i = childNodeNum - 1; i >= 0; --i) {
                stack.push(node.getChild(i));
            }
            visited.put(node, 0);
        }
        // Hash Trees
        Map<Integer, Short> hashCount = new HashMap<>();
        short defualtValue = 0;
        for (int v: visited.values()) {
            hashCount.put(v, (short)(hashCount.getOrDefault(v, defualtValue)+1));
        }
        return hashCount;
    }
}
